# **Rapport d'Analyse - Apache Kafka & Kafka Streams**

## **1. Introduction**
Apache Kafka est une plateforme de streaming distribu√©e permettant de traiter de grandes quantit√©s de donn√©es en temps r√©el. Ce projet vise √† exploiter Kafka pour deux sc√©narios distincts :

1. **Exercice 2 : Kafka Message Processing & Comparaison avec JMS** - √âtude de la production et consommation de messages avec Kafka et comparaison avec JMS.
2. **Exercice 3 : Kafka Streams - Monitoring des Temp√©ratures** - Mise en place d'un traitement de flux en temps r√©el pour surveiller les temp√©ratures des b√¢timents.

Ce rapport d√©taille la conception des programmes et les aspects techniques essentiels mis en ≈ìuvre.

---

## **2. Exercice 2 : Kafka Message Processing & Comparaison avec JMS**

### **2.1 Objectif**
L'objectif est de :
- Mettre en place un **Kafka Producer** pour envoyer un grand volume de messages dans un topic Kafka.
- D√©velopper un **Kafka Consumer** pour consommer ces messages et mesurer le temps de traitement.
- Exp√©rimenter avec **diff√©rentes strat√©gies de consommation**.
- Comparer les performances de Kafka avec JMS.

### **2.2 Conception du Programme**

#### **2.2.1 Kafka Producer**
Le producteur envoie **1 million de messages** dans un topic Kafka avec **2 partitions** pour assurer une meilleure distribution des messages.

- **Technologies utilis√©es** : Java, Kafka Producer API, Maven.
- **Code principal** :
  ```java
  ProducerRecord<String, String> record = new ProducerRecord<>(TOPIC_NAME, key, message);
  producer.send(record);
  ```

#### **2.2.2 Kafka Consumer**
Deux strat√©gies de consommation ont √©t√© test√©es :
1. **Plusieurs consommateurs dans un m√™me groupe** : Kafka distribue les messages entre eux.
2. **Consommateurs dans diff√©rents groupes** : Chaque consommateur re√ßoit tous les messages.

- **Mesure des performances** : Temps total de consommation enregistr√©.
- **Code principal** :
  ```java
  consumer.subscribe(Collections.singletonList(TOPIC_NAME));
  while (true) {
      ConsumerRecords<String, String> records = consumer.poll(Duration.ofMillis(100));
      for (ConsumerRecord<String, String> record : records) {
          System.out.println("Message consomm√© : " + record.value());
      }
  }
  ```

### **2.3 Analyse des R√©sultats**
| Strat√©gie | Nombre de consommateurs | Temps total (ms) |
|-----------|------------------------|-----------------|
| M√™me groupe | 2 consommateurs | 941, 991 |
| M√™me groupe | 3 consommateurs | 3974, 4042 |
| Groupes diff√©rents | 2 consommateurs | 1122, 1117 |
| Groupes diff√©rents | 3 consommateurs | 1117, 1200 |

‚úÖ **Observation :** Kafka est plus performant que JMS pour le traitement de grandes quantit√©s de donn√©es en parall√®le.

### **2.4 Comparaison avec JMS**
| Fonctionnalit√© | Kafka | JMS |
|--------------|------|----|
| Mode de communication | Publish/Subscribe et Queue | Publish/Subscribe et Queue |
| Scalabilit√© | Tr√®s scalable | Moins scalable |
| R√©tention des messages | Stocke les messages | Messages effac√©s apr√®s consommation |
| Performance | Tr√®s rapide | Moins performant |
| Garantie d‚Äôordre | Assur√©e par partitions | Assur√©e par files d‚Äôattente |

‚úÖ **Conclusion** : Kafka est plus adapt√© aux **syst√®mes big data** et au **traitement en temps r√©el**, tandis que JMS convient mieux aux **transactions d'entreprise**.

---

## **3. Exercice 3 : Kafka Streams - Monitoring des Temp√©ratures**

### **3.1 Objectif**
- Simuler **des capteurs de temp√©rature** dans plusieurs b√¢timents.
- Utiliser **Kafka Streams** pour traiter ces donn√©es en **temps r√©el**.
- Appliquer un **fen√™trage de 5 minutes** pour calculer la moyenne des temp√©ratures par salle.
- D√©tecter et **g√©n√©rer une alerte** si une temp√©rature est inf√©rieure √† **5¬∞C** ou sup√©rieure √† **30¬∞C**.

### **3.2 Conception du Programme**

#### **3.2.1 Kafka Multi-Producteurs**
- Chaque producteur **repr√©sente un b√¢timent** et envoie des **temp√©ratures toutes les 10 secondes**.
- **Format du message produit** :
  ```json
  {
    "Building1": [
      {"salle": "salle0", "temperature": 19.4},
      {"salle": "salle1", "temperature": 3.2}
    ]
  }
  ```

#### **3.2.2 Kafka Streams Processing**
- **Consomme les messages depuis `topic1`**.
- **Groupe les messages par salle** et applique **un fen√™trage de 5 minutes**.
- **Calcule la moyenne des temp√©ratures**.
- **Envoie une alerte vers `topic_alerts` si n√©cessaire**.

- **Code principal** :
  ```java
  KTable<Windowed<String>, Double> avgTemperatureByRoom = temperatureStream
      .groupByKey(Grouped.with(Serdes.String(), Serdes.Double()))
      .windowedBy(TimeWindows.of(Duration.ofMinutes(5)))
      .aggregate(
          () -> 0.0,
          (salle, temperature, avg) -> (avg + temperature) / 2,
          Materialized.with(Serdes.String(), Serdes.Double())
      );
  ```

### **3.3 R√©sultats et Analyse**
- **Les moyennes sont calcul√©es et stock√©es** en temps r√©el.
- **Les alertes sont envoy√©es imm√©diatement** si une temp√©rature est hors seuil.
- **Exemple d'alerte** re√ßue :
  ```json
  üö® Alerte Temp√©rature - Salle: salle3 | Temp Moyenne: 30.8¬∞C
  üö® Alerte Temp√©rature - Salle: salle1 | Temp Moyenne: 4.2¬∞C
  ```

---

## **4. Conclusion G√©n√©rale**
‚úÖ **Exercice 2 : Kafka est performant pour la gestion de messages en masse** et offre une **meilleure scalabilit√© que JMS**.  
‚úÖ **Exercice 3 : Kafka Streams permet de traiter les donn√©es en temps r√©el** et d‚Äôimpl√©menter facilement des **syst√®mes de monitoring**.  
‚úÖ **Kafka est donc adapt√© aux architectures modernes** n√©cessitant du **Big Data, de l‚ÄôEvent Streaming et du traitement en temps r√©el**.

---

## **5. R√©f√©rences**
- [Kafka Streams : Windowing Concepts](https://senthilnayagan.medium.com/windowing-in-kafka-streams-513fc0b410c9)
- [Gson Library pour Parsing JSON](https://howtodoinjava.com/gson/gson/)
- [Apache Kafka Documentation](https://kafka.apache.org/documentation/)

üöÄ **Ce projet permet d‚Äôexp√©rimenter Kafka pour le message processing et le traitement en temps r√©el !** üéØüî•

